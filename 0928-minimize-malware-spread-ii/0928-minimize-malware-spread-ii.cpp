class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int totalNodes = graph.size();

        vector<vector<int>> adjacencyList(totalNodes);
        for (int i = 0; i < totalNodes; i++) {
            for (int j = 0; j < totalNodes; j++) {
                if (graph[i][j]) {
                    adjacencyList[i].push_back(j);
                }
            }
        }

        int minimumInfected = totalNodes;
        int answerNode = *min_element(initial.begin(), initial.end());

        for (int blockedNode : initial) {
            vector<bool> visited(totalNodes, false);
            queue<int> bfsQueue;
            int infectedCount = 0;

            for (int infectedNode : initial) {
                if (infectedNode == blockedNode) continue;
                bfsQueue.push(infectedNode);
                visited[infectedNode] = true;
                infectedCount++;
            }

            while (!bfsQueue.empty()) {
                int currentNode = bfsQueue.front();
                bfsQueue.pop();

                for (int neighbor : adjacencyList[currentNode]) {
                    if (neighbor == blockedNode) continue;
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        bfsQueue.push(neighbor);
                        infectedCount++;
                    }
                }
            }

            if (infectedCount < minimumInfected ||
               (infectedCount == minimumInfected && blockedNode < answerNode)) {
                minimumInfected = infectedCount;
                answerNode = blockedNode;
            }
        }

        return answerNode;
    }
};